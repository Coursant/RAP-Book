# Chapter 5.1. Alias Analysis
Alias analysis involves determining if two identifiers point to the same memory allocation. The task is challenging, with various options that balance precision and cost, including flow sensitivity, field sensitivity, and path sensitivity. In general, there are two main approaches to analysis: the lattice-based approach and the meet-over-all-paths (MOP) approach.

## 5.1.1 Alias Analysis Trait
RAPx provides the [`AliasAnalysis`](https://docs.rs/rapx/latest/rapx/analysis/core/alias_analysis/trait.AliasAnalysis.html) trait for alias analysis. The trait has several methods, which enables users to query the aliases among the arguments and return value of a function based on the function `DefId`, or the aliases of all functions as a `FxHashMap`. Developers can implement the trait based on their needs.
```rust
pub trait AliasAnalysis: Analysis {
    fn get_fn_alias(&self, def_id: DefId) -> Option<FnAliasPairs>;
    fn get_all_fn_alias(&self) -> FnAliasMap;
    fn get_local_fn_alias(&self) -> FnAliasMap;
}
```

The alias analysis result for each function is stored as the `FnAliasPairs` type, which contains a `HashSet` of multiple alias relationships, and each alias relationship is recorded as `AliasPair`.
```rust
pub struct FnAliasPairs {
    arg_size: usize,
    alias_set: HashSet<AliasPair>,
}
pub struct AliasPair {
    pub left_local: usize, // parameter id; the id of return value is `0`;
    pub lhs_fields: Vec<usize>, // field-sensive: sequence of (sub) field numbers for left_local
    pub right_local: usize, // parameter id, which is an alias of left_local
    pub rhs_fields: Vec<usize>, // field-sensive: sequence of (sub) field numbers for right_local
}
```

RAPx has implemented a default alias analysis algorithm based on MOP.

## 5.1.2 Default Alias Analysis
The MOP-based alias approach is achieved via a struct `AliasAnalyzer`, which implements the `AliasAnalysis` trait. The detailed implementation can be found in [mop.rs](https://github.com/Artisan-Lab/RAPx/blob/main/rapx/src/analysis/core/alias/mop.rs). 
```rust
pub struct AliasAnalyzer<'tcx> {
    pub tcx: TyCtxt<'tcx>,
    pub fn_map: FxHashMap<DefId, MopFnAliasPairs>,
}
```
The results can be retrieved by decoding the data structure of `FnAliasPairs `.

Suposing the task is to analyze the alias relationship among the return values and the arguments, the approach performs alias analysis for each execution path of a target function and merges the results from different paths into a final result. When encountering function calls, it recursively analyzes the callees until all dependencies are resolved. This approach is path-sensitive and field-sensitive but context-insensitive.

### 5.1.2.1 Feature: Path Sensitive with Light Reachability Constraints
In the following code, there are two conditional branches. If adopting a lattice-based approach, `a` could be an alias of either `x` or `y` at program point ①. Consequently, the return value could also be an alias of either `x` or `y`.
However, this analysis is inaccurate, and `a` cannot be an alias of `y` in this program.
In fact, the function `foo` has four execution paths induced by the two conditional branches. Among them, only one path involves an alias relationship between the return value and `y`. This path requires `choice` to be `Selector::Second` in the first conditional statement and `Selector::First` in the second conditional statement, which is impossible. Therefore, this path is unreachable, and `a` should not be considered an alias of `y` in this program.


```rust
enum Selector {
    First,
    Second,
}

fn foo<'a>(x: &'a i32, y: &'a i32, choice: Selector) -> &'a i32 {
    let a = match choice {
        Selector::First => x, 
        Selector::Second => y,
    };
    // program point ①.
    match choice {
        Selector::First => a, 
        Selector::Second => x,
    }
}
```

Our MOP-based approach can address this issue by explicitly extracting each execution path and justifying its reachability through the maintenance of a set of constant constraints.
We use the following MIR code for illustration, which corresponds to the previous source code. In `bb0`, there is a `SwitchInt()` instruction that branches control flow to `bb3` if `_5` is `0`, to `bb1` if `_5` is `1`, or to `bb2` otherwise.
Accordingly, we impose constant constraints on `_5` along each branch: in `bb3`, `_5` is constrained to be `0`; in `bb1`, `_5` is constrained to be `1`; and in `bb2`, `_5` is constrained to be neither `0` nor `1`. With these constraints in place, when execution reaches the second conditional statement in `bb4`, the analysis can rule out two unreachable combinations of branch conditions.

```rust
fn foo(_1: &i32, _2: &i32, _3: Selector) -> &i32 {
    bb0: {
        StorageLive(_4);
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = _2;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = _1;
        goto -> bb4;
    }

    bb4: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb6, 1: bb5, otherwise: bb2];
    }

    bb5: {
        _0 = _1;
        goto -> bb7;
    }

    bb6: {
        _0 = _4;
        goto -> bb7;
    }

    bb7: {
        StorageDead(_4);
        return;
    }
}
```

### 5.1.2.2 Feature: Path Sensitive with Light Reachability Constraints

### 5.1.2.3 Feature: Field Sensitive 

In the following example, the return value of `foo()` is an alias of the first field of its first argument.
```rust
struct Point {
    x: i32,
    y: i32,
}

fn foo(p1: &Point) -> &i32 {
    &p1.y
}
```

The corresponding MIR code is as follows:

```rust
fn foo(_1: &Point) -> &i32 {
   bb0: {
        _0 = &((*_1).1: i32);
        return;
    }
}
```

The alias analysis result should be (0, 1.1).

 
### 5.1.3 Quick Usage Guide

Developers can test the feature using the following command:
```
cargo rapx -alias
```

For example, we can apply the mop analysis to the first case, and the result is as follows:
```shell
Checking alias_mop_field...
21:50:18|RAP|INFO|: Start analysis with RAP.
21:50:18|RAP|INFO|: Alias found in Some("::boxed::{impl#0}::new"): {(0.0,1)}
21:50:18|RAP|INFO|: Alias found in Some("::foo"): {(0,1.1),(0,1.0)}
```

When applying the mop analysis to the first case, and the result is as follows:

```shell
Checking alias_mop_switch...
21:53:37|RAP|INFO|: Start analysis with RAP.
21:53:37|RAP|INFO|: Alias found in Some("::foo"): {(0,2),(0,1)}
21:53:37|RAP|INFO|: Alias found in Some("::boxed::{impl#0}::new"): {(0.0,1)}
```

To utilize the analysis results in other analytical features, developers can refer the following example:

```rust
let mut alias_analysis = AliasAnalyzer::new(self.tcx);
alias_analysis.run();
let result = alias_analysis.get_local_fn_alias();
rap_info!("{}", AAResultMapWrapper(result));
```

The code above performs alias analysis for each function, recording the alias pairs between two arguments or between an argument and the return value. 

### Key Steps of Our Algorithm
There are three key steps ([source code](https://github.com/Artisan-Lab/RAP/blob/f76b764cb5b66ccfddd19dc083586b7a6a90b576/rap/src/analysis/core/alias/mop.rs#L57C13-L59C50)):
```rust
let mut mop_graph = MopGraph::new(self.tcx, def_id);
mop_graph.solve_scc();
mop_graph.check(0, &mut self.fn_map);
```

* **Graph preparation**: Construct the control-flow graph for the target function. See the [source code](https://github.com/Artisan-Lab/RAPx/blob/4ead41498bc24c77e84502e8da0bac87d1bcc5f4/rapx/src/analysis/core/alias_analysis/default/graph.rs#L135C1-L135C4).
* **SCC shrinkage**: Extract the strongly connected components (SCCs) and shrink SCCs of the control-flow graph. See the [source code](https://github.com/Artisan-Lab/RAPx/blob/4ead41498bc24c77e84502e8da0bac87d1bcc5f4/rapx/src/analysis/core/alias_analysis/default/graph.rs#L463).
* **Alias Check**: Traversal the control-flow graph and perform alias analysis. See the [source code](https://github.com/Artisan-Lab/RAPx/blob/4ead41498bc24c77e84502e8da0bac87d1bcc5f4/rapx/src/analysis/core/alias_analysis/default/mop.rs#L56)

### Reference
The feature is based on our SafeDrop paper, which was published in TOSEM.  
```
@article{cui2023safedrop,
  title={SafeDrop: Detecting memory deallocation bugs of rust programs via static data-flow analysis},
  author={Mohan Cui, Chengjun Chen, Hui Xu, and Yangfan Zhou},
  journal={ACM Transactions on Software Engineering and Methodology},
  volume={32},
  number={4},
  pages={1--21},
  year={2023},
  publisher={ACM New York, NY, USA}
}
